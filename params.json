{"name":"Openframeworks DatGui","tagline":"A port of the popular JavaScript UI to OpenFrameworks","body":"##ofxDatGui\r\n\r\n**ofxDatGui** is a **simple to use**, fully customizable, high-resolution graphical user interface for [openFrameworks](http://openframeworks.cc/) inspired by the popular JavaScript [datgui](http://workshop.chromeexperiments.com/examples/gui/) interface.  \r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_.png)\r\n\r\n##Features\r\n\r\n**ofxDatGui** offers the following features & components:\r\n\r\n* Click & Toggle (On/Off) Buttons\r\n* Text Input Fields\r\n* Color Pickers\r\n* Range Sliders\r\n* Dropdown Menus\r\n* Button Matrices\r\n* Coordinate Pads\r\n* Value Plotters\r\n* Waveform Monitors\r\n* Framerate Monitor\r\n* Variable Binding\r\n* Completely Customizable\r\n* Folders to group components together\r\n* An optional header & footer that allow you to title the gui, collapse and drag it around\r\n\r\n\r\n##Installation\r\n\r\n**ofxDatGui** is built on top of C++11 and requires the new openFrameworks 0.9.0 pre-release which you can [download here](http://forum.openframeworks.cc/t/0-9-0-release-candidate-1/20434).\r\n\r\n* Once you've downloaded [openFrameworks](http://forum.openframeworks.cc/t/0-9-0-release-candidate-1/20434), clone or download this repository into your openFrameworks/addons directory.\r\n\r\n* Create a new project using the project generator and include **ofxDatGui** by selecting the ```addons``` button in the generator.\r\n\r\n* Copy the ```ofxdatgui_assets``` directory in the root of this repository to your project's bin/data directory. This directory contains the fonts & icons used by **ofxDatGui**.\r\n\r\n* Add **ofxDatGui** to your project by adding  ```#include \"ofxDatGui.h\"``` to the top of your ```ofApp.h``` file and you're ready to go!\r\n\r\n##Getting Started\r\n\r\nThere are two ways to work with **ofxDatGui**. You can either instantiate each component on its own or consolidate them into a gui panel that you can drag around. The individual component examples included in this repository demonstrate how to use each on its own.\r\n\r\n\r\nTo create an **ofxDatGui** panel that groups components together simply pass in the X and Y coordinates where you would like it to live or use one of the convenient pre-defined anchors.\r\n\r\n\tofxDatGui* gui = new ofxDatGui( 100, 100 );\r\n\tofxDatGui* gui = new ofxDatGui( ofxDatGuiAnchor::TOP_LEFT );\r\n\tofxDatGui* gui = new ofxDatGui( ofxDatGuiAnchor::TOP_RIGHT );\r\n\r\nAdding components to **ofxDatGui** is as simple as:\r\n\r\n\tgui->addButton(\"Click!\");\r\n\t\r\nThis generates a Basic Button with the label \"Click!\"\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_click.png)\r\n\r\n## Interactive Components\r\n \r\n**ofxDatGui** currently offers the following interactive components:\r\n  \r\n**Text Input**\r\n \r\n\tgui->addTextInput(string label, string value = \"\");\r\n\t\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_input.png?raw=true)\r\n  \r\n**Basic Button**\r\n\t \t\r\n\tgui->addButton(string label);\r\n\t\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_click.png?raw=true)\t\r\n\t\r\n**Toggle Button**\r\n\r\n\tgui->addToggle(string label, bool enabled = true);\r\n\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_toggle.png?raw=true)\r\n\r\n**Range Slider**\r\n\r\n\tgui->addSlider(string label, float min, float max);\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_slider.png?raw=true)\r\n\t\r\nYou can also set the starting value of the slider.  \r\nIf this is not set it will default to halfway between the min and max values.\r\n\r\n\tgui->addSlider(string label, float min, float max, float value);\r\n\t\r\n**Color Picker**\t\r\n\t\r\n\tgui->addColorPicker(string label, ofColor color = ofColor::black);\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_color.png?raw=true)\r\n\t\r\n**Dropdown Menu**\r\n\t\r\n\tvector<string> options = {\"ONE\", \"TWO\", \"THREE\", \"FOUR\"};\r\n\tgui->addDropdown(options);\r\n\t\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_dropdown.png?raw=true)\r\n\r\n**Value Plotter**\r\n\t\r\n\tgui->addValuePlotter(string label, float min, float max);\r\n\r\n![ofxDatGui](./readme-img/ofxdatgui_value_plotter.gif?raw=true)\r\n\r\n**Waveform Monitor**\r\n\t\r\n\tgui->addWaveMonitor(string label, float frequency, float amplitude);\r\n\r\n![ofxDatGui](./readme-img/ofxdatgui_wave_monitor.gif?raw=true)\r\n\r\n**Value Plotters** and **Waveform Monitors** support four different draw modes:\r\n\r\n\tofxDatGuiGraph::LINES\r\n\tofxDatGuiGraph::FILLED\r\n\tofxDatGuiGraph::POINTS\r\n\tofxDatGuiGraph::OUTLINE\r\n\r\n\tofxDatGuiValuePlotter* plotter = new ofxDatGuiValuePlotter(\"my plotter\", 0, 100);\r\n\t// set the drawmode to \"points\" //\r\n\tplotter->setDrawMode(ofxDatGuiGraph::POINTS);\r\n\r\n----\r\n\r\n**Button Matrix**\r\n\r\n\tgui->addMatrix(string label, int numButtons)\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_matrix.png?raw=true)\r\n\r\nYou can display numbered labels on the buttons by passing ``true`` as the third argument.\r\n\r\n\tgui->addMatrix(string label, int numButtons, bool showLabels)\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_matrix_labels.png?raw=true)\r\n\r\n**2D Coordinate Pad**\r\n\r\n\tgui->add2dPad(string label, ofRectangle bounds);\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_2dpad.png?raw=true)\r\n\r\nThe bounds parameter is optional and will default to the window dimensions if omitted.\r\n\r\n##Utility Components\r\n\r\n**ofxDatGui** also provides a few non-interactive utility components to assist with layout and application health monitoring.\r\n\r\n**Label**\r\n  \r\n \tgui->addLabel(string label);\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_label.png?raw=true)\r\n\r\n**Framerate Monitor**\r\n\t\r\n\tgui->addFRM(float refreshFrequency = 1.0f);\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_fps.gif?raw=true)\r\n\r\n**Break**\r\n\r\n\tgui->addLabel(\"Above\");\r\n\tgui->addBreak(float height = 10.0f);\r\n\tgui->addLabel(\"Stuck in the Middle\");\r\n\tgui->addBreak(float height = 10.0f);\r\n\tgui->addLabel(\"Below\");\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_break.png?raw=true)\r\n\r\n##Headers & Footers\r\n\r\n**ofxDatGui** also provides an optional header and footer that allows you to title your gui, drag it around and conveniently collapse and expand it. The ```AllComponentsGui``` example offers a nice demonstration of their use.\r\n\r\n\tgui->addHeader(\":: Drag Me To Reposition ::\");\r\n\t\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_header.png?raw=true)\r\n\t\r\n\tgui->addFooter();\r\n \r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_footer.png?raw=true)\r\n\r\nYou can change the header's label just like any other component by calling:\r\n\r\n```cpp\r\ngui->getHeader()->setLabel(\"PANEL 1\");\r\n```\r\nFooters however have two labels that each map to the gui's expanded and collapsed states.<br>By default these labels are \"Collapse Controls\" and \"Expand Controls\" although you can override these defaults via:\r\n\r\n```cpp\r\ngui->getFooter()->setLabelWhenExpanded(\"CLOSE PANEL 1\");\r\ngui->getFooter()->setLabelWhenCollapsed(\"EXPAND PANEL 1\");\r\n```\r\n\r\n##Component Groups (Folders)\r\n\r\nYou can also group related components into folders. When constructing a folder pass in a label to name the folder and an optional color to help visually group its contents.\r\n\r\n```cpp\r\nofxDatGuiFolder* folder = gui->addFolder(\"My White Folder\", ofColor::white);\r\nfolder->addTextInput(\"** Input\", \"A Nested Text Input\");\r\nfolder->addSlider(\"** Slider\", 0, 100);\r\nfolder->addToggle(\"** Toggle\", false);\r\n```\r\n\r\n![ofxDatGui](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/readme-img/ofxdatgui_folder.png?raw=true)\r\n\t\r\nAll components can be nested into folders with the exception of other folders and dropdowns.\r\n\r\n---\r\n\t\r\nFolders and dropdown menus can also be expanded and collapsed programmatically.\r\n\r\n\tfolder->expand();\r\n\tfolder->collapse();\r\n\t\r\n## Manipulation\r\n\r\nEvery ``gui->add*`` method returns a pointer to an **ofxDatGuiItem** object that you can store in a variable for later manipulation.\r\n\r\n\tofxDatGuiTextInput* myInput;\r\n\tmyInput = gui->addTextInput(\"Name:\", \"Stephen\");\r\n\tmyInput->setText(\"Freddy\");\r\n\t\r\nEvery **ofxDatGuiItem** has a mutable label that can easily be retrieved or changed via:\r\n\r\n\titem->getLabel();\r\n\titem->setLabel(string label);\r\n\t\r\nIn addition some components have methods (typically getters & setters) that allow for the retrieval and manipulation of its unique properties.\r\n\t\r\n**Text Input**\r\n \r\n```cpp\r\nofxDatGuiTextInput* myInput;\r\nstring myInput->getText();\r\nmyInput->setText(string text);\r\n```\t\r\n**Toggle Button**\r\n\r\n```cpp\r\nofxDatGuiToggle* myToggle;\r\nmyToggle->toggle();\r\nmyToggle->setEnabled(bool enable);\r\nbool myToggle->getEnabled();\r\n```\r\n**Range Slider**\r\n\r\n```cpp\r\nofxDatGuiSlider* mySlider;\r\nfloat mySlider->getScale(); \r\nmySlider->setScale(float scale); // a value between 0 & 1 //\r\nfloat mySlider->getValue();\r\nmySlider->setValue(float value); // a value between min & max //\r\n```\r\n\r\n**Color Picker**\r\n\t\r\n```cpp\t\r\nofxDatGuiColorPicker* myColorPicker;\r\nofColor myColorPicker->getColor();\r\nmyColorPicker->setColor(int hexValue);\r\nmyColorPicker->setColor(int r, int g, int b);\r\nmyColorPicker->setColor(ofColor color);\r\n```\r\n\t\r\n**Dropdown Menu**\r\n\r\n```cpp\t\r\nofxDatGuiDropdown* myDropdown;\r\nint myDropdown->size();\r\nmyDropdown->select(int index);\r\nofxDatGuiDropdownOption* getChildAt(int index);\r\nofxDatGuiDropdownOption* myDropdown->getSelected();\r\nmyDropdown->expand();\r\nmyDropdown->collapse();\r\n```\r\n\t\r\n**ofxDatGuiMatrix**\r\n\r\n```cpp\t\r\nofxDatGuiMatrix* myMatrix;\r\nofxDatGuiMatrixButton* myMatrix->getChildAt(int index);\r\nvector<int> myMatrix->getSelected();\r\n// returns a vector containing the indicies of the selected buttons //\r\nmyMatrix->clear(); // deselects all buttons in the matrix //\r\n```\r\n\r\n**ofxDatGui2dPad**\r\n\r\n```cpp\t\r\nofxDatGui2dPad* my2dPad;\r\nmy2dPad->setBounds(ofRectangle bounds);\r\nofPoint my2dPad->getPosition();\r\n// returns the current position within the bounds rectangle you gave it //\r\n```\t\r\n\t\r\n**Note:** All indicies are zero based so the first item in your  **ofxDatGui** instance will have an index of 0, the second item will have an index of 1, the third item an index of 2 etc..\r\n\t\r\n## Component Retrieval\r\n\r\nIf you're lazy and don't feel like storing your components in variables you can easily retrieve them by name which by default is the same as whatever you set its label to.\r\n\r\n\tofxDatGuiButton* gui->getButton(\"My Button\"); // button name\r\n\tofxDatGuiSlider* gui->getSlider(\"My Slider\"); // slider name\r\n\t\r\nNote: ``gui->getComponent`` performs a case-insensitive lookup against the component's name so the following works fine as well.\r\n\r\n\tofxDatGuiButton* gui->getButton(\"my bUTTon\"); // button name\r\n\tofxDatGuiSlider* gui->getSlider(\"mY sLiDEr\"); // slider name\r\n\t\r\nTo change a component's label or name simply:\r\n\r\n\tgui->getButton(\"My Button\")->setName(\"b1\");\r\n\tgui->getButton(\"b1\")->setLabel(\"Your Button\");\r\n\t\r\nIf you have multiple components with the same name nested in separate folders just specify the folder to search.\r\n\r\n\tofxDatGuiButton* gui->getButton(\"Reset Button\", \"Folder 1\");\r\n\tofxDatGuiButton* gui->getButton(\"Reset Button\", \"Folder 2\");\r\n\t\r\nOtherwise the function will return the first component whose name & type match the query.\r\n\t\r\n## Variable Binding\r\n\r\n**ofxDatGui** sliders & coordinate pads can also be bound to object variables. Just pass a reference to the variable to the component and set a range by which to limit its movement.\r\n\r\nFor example the following snippet binds a circle's position to a range slider and limits its movement to the width & height of the screen.\r\n\r\n```cpp\r\n// draw a circle with a radius of 100px\r\n// and position it in the middle of the screen //\r\n\tcircle = new Circle(100);\r\n\tcircle->x = ofGetWidth()/2;\r\n\tcircle->y = ofGetHeight()/2;\r\n    \r\n// instantiate a gui and a couple of range sliders //\r\n\tgui = new ofxDatGui( ofxDatGuiAnchor::TOP_RIGHT );\r\n\tofxDatGuiSlider* sx = gui->addSlider(\"CIRCLE X\", 0, 100);\r\n\tofxDatGuiSlider* sy = gui->addSlider(\"CIRCLE Y\", 0, 100);\r\n    \r\n// bind the circle's x & y movement to the sliders //\r\n\tsx->bind(&circle->x, 0, ofGetWidth());\r\n\tsy->bind(&circle->y, 0, ofGetHeight());\r\n```\r\n\t\r\n## Events\r\n\r\n**ofxDatGuiEvents** are designed to be as easy as possible to interact with.\r\n\r\nTo listen for an event simply register a callback to be executed when an event you care about is fired:\r\n\t\r\n\tgui->onButtonEvent(this, &ofApp::onButtonEvent);\r\n\tvoid onButtonEvent(ofxDatGuiButtonEvent e)\r\n\t{\r\n\t\tcout << \"A button was clicked!\" << endl;\r\n\t}\r\n    \r\nEvery callback you register will receive an event object that contains a pointer (called target) to the object that created the event. \r\n\r\n\tgui->addButton(\"My Button\");\r\n\tgui->onButtonEvent(this, &ofApp::onButtonEvent);\r\n\tvoid onButtonEvent(ofxDatGuiButtonEvent e)\r\n\t{\r\n\t\tcout << e.target->getLabel() << endl; // prints \"My Button\"\r\n\t}\r\n\r\nIf you saved the pointer returned by ``gui->add*`` in a variable you can compare it to the event target to decide how to handle the event. \r\n\r\n\tofxDatGuiButton* b1 = gui->addButton(\"Button 1\");\r\n\tofxDatGuiButton* b2 = gui->addButton(\"Button 2\");\r\n\tgui->onButtonEvent(this, &ofApp::onButtonEvent);\r\n\tvoid onButtonEvent(ofxDatGuiButtonEvent e)\r\n\t{\r\n\t\tif (e.target == b1){\r\n\t\t\tcout << \"Button 1 was clicked\" << endl;\r\n\t\t} else if (e.target == b2){\r\n\t\t// \tbutton 2 was clicked, do something else //\r\n\t\t}\r\n\t}\r\n\t\r\nHowever a more convenient way of determining which component dispatched the event is by using the built in ``is`` operator.\r\n\r\n\tgui->addButton(\"Button 1\");\r\n\tgui->addButton(\"Button 2\");\r\n\t\t\r\n\tvoid onButtonEvent(ofxDatGuiButtonEvent e)\r\n\t{\r\n\t\tif (e.target->is(\"button 1\")){\r\n\t\t\tcout << \"Button 1 was clicked\" << endl;\r\n\t\t} else if (e.target->is(\"button 2\")){\r\n\t\t// \tbutton 2 was clicked, do something else //\r\n\t\t}\r\n\t}\r\n\t\r\nThis performs a case-insensitive search against the component's name which by default is the same as its label.\r\n\r\n****\r\n\r\nAll events also contain additonal properties that allow convenient access to the state of the component that dispatched the event.\r\n\r\n**ofxDatGuiButtonEvent**\r\n\r\n\tofxDatGuiButtonEvent e\r\n\tbool e.enabled // the enabled state of a toggle button\r\n\t\t\t\r\n**ofxDatGuiSliderEvent**\r\n\r\n\tofxDatGuiSliderEvent e\r\n\tfloat e.value // current value of the slider \r\n\tfloat e.scale // current scale of the slider \r\n\r\n**ofxDatGuiTextInputEvent**\r\n\t\r\n\tofxDatGuiTextInputEvent e\r\n\tstring e.text // current text in the textfield\r\n\t\r\n**ofxDatGuiColorPickerEvent**\r\n\r\n\tofxDatGuiColorPickerEvent e\r\n\tofColor e.color // the color of the picker\r\n\t\r\n**ofxDatGui2dPadEvent**\r\n\r\n\tofxDatGui2dPadEvent e\r\n\tfloat e.x // x coordinate within the pad's bounds rectangle\r\n\tfloat e.y // y coordinate within the pad's bounds rectangle\r\n\t \r\n**ofxDatGuiDropdownEvent**\r\n\t\r\n\tofxDatGuiDropdownEvent e\r\n\tint e.child // the index of the selected option (zero based)\r\n\t\r\n**ofxDatGuiMatrixEvent**\r\n\t\r\n\tofxDatGuiMatrixEvent e\r\n\tint e.child // the index of the selected button (zero based)\r\n\tbool e.enabled // enabled state of the selected button\r\n\t\r\n**Note:** You can also retrieve these properties directly from the event target itself.\r\n\r\n\tofxDatGuiSliderEvent e\r\n\tfloat value = e.target->getValue();\r\n\tfloat scale = e.target->getScale();\r\n \r\n##Customization\r\n\r\nJust about every aspect of **ofxDatGui's** appearance can be tailored to meet your needs.\r\n\r\nCustomization is accomplished via extensible templates where you define how you want **ofxDatGui** to render.\r\n\r\nJust create a class that extends ``ofxDatGuiTemplate`` and pass it to **ofxDatGui** or any component via ``gui->setTemplate()``\r\n\r\n```cpp\r\nclass myCustomTemplate : public ofxDatGuiTemplate\r\n{\r\n    public:\r\n        myCustomTemplate() {\r\n        // row characteristics //\r\n            row.width\t= 540;\r\n            row.height\t= 52;\r\n            row.padding\t= 4;\r\n            row.spacing\t= 2;\r\n            row.stripeWidth = 4;\r\n        // font characteristics //\r\n            font.file\t= \"PillGothic-Light.ttf\"\r\n            font.size   = 12;\r\n            font.highlightPadding = 4;\r\n        // gui / component colors //\r\n            row.color.bkgd\t= ofColor::lightGray;\r\n            row.color.label\t= ofColor::fromHex(0xFFD00B);\r\n            row.color.mouseOver\t= ofColor::fromHex(0x2FA1D6);\r\n            row.color.mouseOver = ofColor::fromHex(0x777777);\r\n            row.color.inputArea = ofColor::fromHex(0x303030);\r\n\t\t// after everything is setup initialize the template // \r\n            init();\r\n        }\r\n};\r\n// assign this template to a gui instance //\r\n\tgui = new ofxDatGui();\r\n\tgui->setTemplate(new myCustomTemplate());\r\n\r\n```\r\n\r\nTake a look at the [ofxDatGuiTemplate](https://raw.githubusercontent.com/braitsch/ofxDatGui/master/src/templates/ofxDatGuiTemplate.h) base class for a list of everything that can be customized.\r\n\r\n---\r\n\r\nAdditionally all components and gui instances provide the following instance methods.\r\n\r\n \tsetWidth(int width);\r\n \tsetOrigin(int x, int y);\r\n\tsetOpacity(float opacity); // a value between 0 & 1 //\r\n\tsetVisible(bool visible);\r\n\tsetEnabled(bool enabled);\r\n\tsetAlignment(ofxDatGuiAlignment alignment);\r\n\r\n##Label Alignment\r\n\r\nYou can set the label alignment for each component or on **ofxDatGui** itself via:\r\n\r\n\tgui->setAlignment(ofxDatGuiAlignment alignment);\r\n\r\nValid values are:\r\n \r\n \tofxDatGuiAlignment::LEFT\r\n \tofxDatGuiAlignment::CENTER\r\n \tofxDatGuiAlignment::RIGHT\r\n\r\n##Automatic Rendering\r\n\r\n**ofxDatGui** automatically updates and draws itself on top of your application so there is no need to call ```update``` or ```draw``` on it. However you can easily disable this if you like via:\r\n\r\n\tgui->setAutoDraw(bool enabled);\r\n\r\n##Logging\r\n\r\n**ofxDatGui** will softly warn you if you forget to attach an event listener to a component you've created or if you attempt to perform an action on a component that does not exist.\r\n\r\n\t[ERROR] :: Component Not Found : GHOST BUTTON\r\n\t[WARNING] :: Event Handler Not Set : MY BUTTON\r\n\r\nHowever you can easily suppress these warnings by calling:\r\n\r\n\tofxDatGuiLog::quiet();\r\n\r\n##Save & Load Settings\r\n\r\n\tComing Soon\r\n\r\n\r\n##Additonal Notes\r\n\r\nThanks for reading all this and checking the project out. \r\n\r\nI'm actively looking for people to help me test this and provide feedback to help shape ongoing development. If you'd like to see a feature prioritized or have any general questions or feedback please send me a message or open an issue here on Github.\r\n\r\nThanks!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}